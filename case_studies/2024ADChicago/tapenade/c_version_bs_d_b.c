/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.16 (develop) - 25 Oct 2024 09:00
*/
#include "adStack.h"
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.16 (develop) - 25 Oct 2024 09:00
*/
#include <math.h>
#include <stdio.h>

/*
  Differentiation of cdf_n_d in reverse (adjoint) mode:
   gradient     of useful results: cdf_n_d *cdf_n
   with respect to varying inputs: xd x *cdf_n
   Plus diff mem management of: cdf_n:in


  Differentiation of cdf_n in forward (tangent) mode:
   variations   of useful results: cdf_n
   with respect to varying inputs: x
*/
void cdf_n_d_b(double x, double *xb, double xd, double *xdb, double *cdf_n,
        double *cdf_nb, double cdf_n_db) {
    double temp;
    temp = -(0.70710678118654746*0.70710678118654746*(x*x));
    *xb = 0.70710678118654746*1.1283791671*exp(-(-(0.70710678118654746*x)*-(
        0.70710678118654746*x)))*0.5*(*cdf_nb) - 2*x*pow(0.70710678118654746,
        3)*exp(temp)*xd*1.1283791671*0.5*cdf_n_db;
    *xdb = exp(temp)*1.1283791671*0.70710678118654746*0.5*cdf_n_db;
    *cdf_nb = 0.0;
}

/*
  Differentiation of cdf_n in forward (tangent) mode:
   variations   of useful results: cdf_n
   with respect to varying inputs: x
*/
double cdf_n_d_nodiff(double x, double xd, double *cdf_n) {
    *cdf_n = 0.5*erfc(x*-0.70710678118654746);
    return 0.5*1.1283791671*exp(-(-(0.70710678118654746*x)*-(
    0.70710678118654746*x)))*0.70710678118654746*xd;
}

/*
  Differentiation of call_price_d in reverse (adjoint) mode:
   gradient     of useful results: Td v Kd call_price_d *call_price
                vd Sd K S T
   with respect to varying inputs: Td v Kd *call_price vd Sd K
                S T
   RW status of diff variables: Td:incr v:incr Kd:incr call_price_d:in-killed
                call_price:(loc) *call_price:in-out vd:incr Sd:incr
                K:incr S:incr T:incr
   Plus diff mem management of: call_price:in


  Differentiation of call_price in forward (tangent) mode:
   variations   of useful results: call_price
   with respect to varying inputs: v K S T
   RW status of diff variables: v:in call_price:out K:in S:in
                T:in
*/
void call_price_d_b(double S, double *Sb, double Sd, double *Sdb, double K,
        double *Kb, double Kd, double *Kdb, double v, double *vb, double vd,
        double *vdb, double T, double *Tb, double Td, double *Tdb, double *
        call_price, double *call_priceb, double call_price_db) {
    double totalvol;
    double totalvolb;
    double totalvold;
    double totalvoldb;
    double result1;
    double result1b;
    double result1d;
    double result1db;
    double result2;
    double result2b;
    double result2d;
    double result2db;

    double temp_pre;

    double temp;
    double tempb;
    double temp0;
    double temp0b;
    double tempb0;
    double temp1;
    double tempb1;
    double tempb2;
    temp_pre = sqrt(T);
    result1d = (T == 0.0 ? 0.0 : Td/(2.0*temp_pre));
    result1 = temp_pre;
    totalvold = result1*vd + v*result1d;
    totalvol = v*result1;
    temp = S/K;
    temp0 = log(temp)/totalvol;
    double d1 = temp0 + 0.5*totalvol;
    double d1b = 0.0;
    double d1d = ((Sd-temp*Kd)/(temp*K)-temp0*totalvold)/totalvol + 0.5*
    totalvold;
    double d1db = 0.0;
    double d2 = d1 - totalvol;
    double d2b = 0.0;
    double d2d = d1d - totalvold;
    double d2db = 0.0;
    pushReal8(result1d);
    pushReal8(result1);
    result1d = cdf_n_d_nodiff(d1, d1d, &result1);
    result2d = cdf_n_d_nodiff(d2, d2d, &result2);
    result1b = Sd*call_price_db + S*(*call_priceb);
    *Sdb = *Sdb + result1*call_price_db;
    *Sb = *Sb + result1d*call_price_db + result1*(*call_priceb);
    result1db = S*call_price_db;
    result2b = -(Kd*call_price_db) - K*(*call_priceb);
    *Kdb = *Kdb - result2*call_price_db;
    *Kb = *Kb - result2d*call_price_db - result2*(*call_priceb);
    result2db = -(K*call_price_db);
    *call_priceb = 0.0;
    d2b = 0.0;
    d2db = 0.0;
    cdf_n_d_b(d2, &d2b, d2d, &d2db, &result2, &result2b, result2db);
    popReal8(&result1);
    popReal8(&result1d);
    d1b = 0.0;
    d1db = 0.0;
    cdf_n_d_b(d1, &d1b, d1d, &d1db, &result1, &result1b, result1db);
    d1db = d1db + d2db;
    d1b = d1b + d2b;
    temp1 = (Sd-temp*Kd)/(temp*K);
    tempb0 = d1db/totalvol;
    totalvoldb = 0.5*d1db - d2db - temp0*tempb0;
    tempb1 = tempb0/(temp*K);
    temp0b = d1b - totalvold*tempb0;
    totalvolb = 0.5*d1b - d2b - (temp1-temp0*totalvold)*tempb0/totalvol - log(
        temp)*temp0b/(totalvol*totalvol);
    *Sdb = *Sdb + tempb1;
    *Kdb = *Kdb - temp*tempb1;
    tempb2 = -(temp1*tempb1);
    tempb = K*tempb2 - Kd*tempb1 + temp0b/(temp*totalvol);
    *Kb = *Kb + temp*tempb2 - S*tempb/(K*K);
    *Sb = *Sb + tempb/K;
    *vb = *vb + result1*totalvolb + result1d*totalvoldb;
    result1b = result1b + v*totalvolb + vd*totalvoldb;
    *vdb = *vdb + result1*totalvoldb;
    result1db = v*totalvoldb;
    tempb0 = (T == 0.0 ? 0.0 : result1db/(2.0*temp_pre));
    tempb = result1b - Td*tempb0/temp_pre;
    *Tdb = *Tdb + tempb0;
    if (!(T==0.0))
        *Tb = *Tb + tempb/(2.0*sqrt(T));
}
